# Network Security - PoC
Here are our 2 Proof of Concept (PoC) for the Network Security project. The first one is about SNI evasion, and the second one is about UDP hole punching.

## SNI Evasion
If you don't want to run the PoC, the `sni.pcap` file contains the traffic captured during the PoC, which you can analyze using `snort` (see command in the section below).

- The snort rules are in the `snort_block_sni.rules` file.
- The `certs` directory contains the self-signed certificate (domain: `bad.com`) used for the QUIC and TCP servers.

### Pre-requisites
- **Mininet**: This is a network emulator that allows you to create virtual networks. (https://mininet.org/download/)
- **aioquic**: This is a Python library for QUIC. (https://github.com/aiortc/aioquic)


### Running the PoC
To start the topology, run the following command:
```bash
sudo python3 topo.py
```
It will launch 3 xterm windows:
1. **serverTCP**: This is the TCP server that will handle incoming connections.
2. **serverHTTP3**: This is the HTTP/3 (QUIC) server that will handle HTTP/3 requests.
3. **Firewall**: This firewall is intended to run the IDS. However, in this case, we were unable to get `snort` running directly within Mininet. Instead, the firewall launches `tcpdump` to capture traffic into a `.pcap` file, which can then be analyzed using `snort` outside of Mininet.

First we have to add the `bad.com` hostname to the `/etc/hosts` file of the `client`, so that it can resolve it correctly (since we don't have a DNS server in this topology):
```bash
client echo "10.0.1.2 bad.com" >> /etc/hosts
```


Then we make the request to the HTTP/3 server using the client:
```bash
client python3 http3_client.py https://bad.com --ca-certs certs/cert.pem # --output-dir output_dirs
```

We make the second request to the TCP server:
```bash
client wget --no-check-certificate https://bad.com:4443
```

And finally, we can analyze the traffic captured by the firewall using `snort`:
```bash
# snort 2.x
sudo snort -k none -l . -c snort_block_sni.rules -r tcpdump.pcap
```
The results should appear in a file called `alert` in the current directory, which will contain the alerts generated by `snort`.


## Hole Punching PoC
This PoC demonstrates how to bypass a stateful firewall using hole punching techniques. The goal is to send unsolicited UDP packets through the firewall by exploiting the established connection.
### Running holepunching PoC

You may verify that the statefull firewall is working correctly.
```bash
client ping server
server ping client
```

You will need to open two terminals
- First in `xterm client` launch `python3 scapy_sniffer.py` to look at all the traffic going through client-eth0.
- Second in `xterm server` launch `python3 hole_punching.py`. This will listen for incoming UDP packet and send back ten unsolicited packets to the sender.
- Quickly after launching hole-punching.py send the QUIC request with
```bash
client python3 http3_client.py https://bad.com --ca-certs certs/cert.pem # --output-dir output_dirs
```
Here are the following steps you can observe:
- Once the `hole_punching.py` detects the incoming traffic, after waiting for three seconds, it will use the IP's and port numbers to send usolicited traffic.
- After which you will be able to see on the `scapy_sniffer.py` terminal that the unsolicited packet have truly made it trough the firewall.
    




